> ### 1 C++中的多态如何理解？
```
多态产生的诉求：接口重用；备注：继承和封装 -- 继承扩展已存在的代码，而封装使得代码模块化，其最终目的是代码重用。
多态的定义：面向对象程序设计（OOP）的一个重要特征，指的是同一接口的不同实现方式，多态允许基类的指针指向子类方法。
多态存在的三个必要条件：继承、接口重写、向上转型。
c++多态的两种实现方式：静态多态（编译阶段，函数重载和泛型编程）、动态多态（运行阶段，虚函数）。

不同语言如何实现多态的机制：C++按照绝对位置查表，查询速度快但基类过多会导致空间开销大；smalltalk按照函数名称查表，查询速度慢但空间开销少。
重载、重写的区别：函数重载必须在同一个类，子类无法重载父类的函数，父类同名函数将被名称覆盖，重载是在编译期间根据参数类型和个数决定函数调用；
               函数重写必须发生于父类与子类之间，并且父类与子类中的函数必须有完全相同的原型，使用virtual声明之后能够产生多态。
```

---
> ### 2 谈谈对虚表的理解？
```
作用：实现C++的多态机制。
其它知识：不同的类具有不同的虚函数表，实例化的多个对象会共用一张虚函数表，验证程序如下：
--------------------------------------------------------------------------
class classA {
    virtual void function() {}
};

int main()
{
    classA *a = new classA();
    printf("%x\n", *(int*)(void*)a);
    for (int i = 0; i < 10000;i++) {
        classA *b = new classA();
        if (*(int*)(void*)a == *(int*)(void*)b) {
            printf("YES\n");
        }
        else {
            printf("NO\n");
            break;
        }
        delete b;
    }
    return 0;
}
--------------------------------------------------------------------------

掌握目标：了解虚表的实现原理，具体可学习如下提供的参考资料：
```
参考资料 
- [多态与虚表详解](https://blog.csdn.net/qq_30145355/article/details/78768950)
- [图说C++对象模型：对象内存布局详解](https://www.cnblogs.com/QG-whz/p/4909359.html)

---
> ### 3 C++ vector的创建和初始化方法
```
（1）默认初始化，容器中没有元素size=0，没有分配内存capacity=0，该初始化方式适用于元素个数未知的情况
vector<int> ilist1;

（2）两种方式等价，ilist2初始化为ilist的拷贝，需保证元素类型相同
vector<int> ilist2(ilist);
vector<int> ilist2  = ilist;

（3）ilist 初始化为列表中元素的拷贝，需保证元素类型相容
vector<int> ilist = {1,2,3.0,4,5,6,7};
vector<int> ilist {1,2,3.0,4,5,6,7};

（4）ilist3初始化为两个迭代器指定范围中元素的拷贝，需保证元素类型相容
vector<int> ilist3(ilist.begin()+2,ilist.end()-1);

（5）默认值初始化，ilist4中将包含7个元素，每个元素进行缺省值初始化，也就是被赋值为0
vector<int> ilist4(7);

（6）指定值初始化，ilist5被初始化为包含7个值为3的int
vector<int> ilist5(7,3);
```

---
> ### 4 对C++ static关键字的理解
```
为什么要引入static？为了将函数中变量的值保存至下一次调用
    函数内部定义的变量，在程序执行到它的定义处时，编译器为它在栈上分配空间，大家知道，函数在栈上分配的空间在此函数执行结束时会释放掉，
这样就产生了一个问题: 如果想将函数中此变量的值保存至下一次调用时，如何实现？ 最容易想到的方法是定义一个全局的变量，但定义为一个全局
变量有许多缺点，最明显的缺点是破坏了此变量的访问范围。

什么时候用static？
    需要一个数据对象为整个类而非某个对象服务,同时又力求不破坏类的封装性,即要求此成员隐藏在类的内部，对外不可见。
```
参考资料：
- [C++中static的作用](https://blog.csdn.net/m0_37962600/article/details/80038089)

---
> ### 5 程序内存结构的理解
```
在冯诺依曼的体系结构中，一个进程必须有：代码段，堆栈段，数据段。

C++程序的内存分区包括：代码区、静态区、堆、栈、文字常量区、bss段
```
参考资料：
- [C++—程序的内存分区](https://www.cnblogs.com/helloworldcode/p/10595781.html)
- [C++——程序的内存结构](https://www.cnblogs.com/Vancamel/p/11832370.html)
- [程序内存空间（代码段、数据段、堆栈段）](https://blog.csdn.net/u014600626/article/details/81533125)
- [什么是“堆”,"栈","堆栈","队列",它们的区别](https://www.cnblogs.com/guoxiaoyan/p/8664150.html)

---
> ### 6 利用sizeof计算类的占用字节数
```
sizeof是一个关键字，它是一个编译时运算符，用于判断变量或数据类型的字节大小；
sizeof运算符可用于获取类、结构、共用体和其他用户自定义数据类型的大小。

类内的普通成员函数不参与sizeof()的统计；一个类如果含有虚函数，则这个类中有一个指向虚函数表的指针。
空结构体或空类占1字节内存；结构体或类的sizeof涉及到字节对齐问题，为什么需要字节对齐？为了加快计算机的取数速度，否则得多花指令周期。
```
参考资料：
- [c++计算一个类的sizeof()](https://blog.csdn.net/shayne000/article/details/88575774)
- [c++中sizeof()的用法介绍](https://www.cnblogs.com/huolong-blog/p/7587711.html)